// 成员指针包括数据成员指针和函数成员指针
// 普通变量、数据成员、函数以及函数成员的参数和返回类型都可以定义为成员指针 毕竟他本质上也是一个分配了存储空间的指针 指向了成员在类中的偏移
// 使用成员指针要稍微注意他的权限问题
// 成员指针指向某个数据成员时 不能通过指针移动将他指向其他数据成员 也不能使用强制类型转换否则会间接地指针移动
// 指针不能移动的原因是可能访问到不允许访问的地方，因为成员之间类型大小、访问权限都不同。要防止错误读取内存空间和越权访问
// 如下程序
#include <iostream>
class A{
    int a;
    int f(){return 1;}
    public:
    int b;
    int g(){return 2;}

};

int main(int argc, char const *argv[])
{
    A a;
    int x;
    // int A::* p_int = & A::a;//错误 因为a是private的
    int A::* p_int = & A::b;    //正确 因为b是public的
    // int (A::* p_fun) () = & A::f;//错误 
    int (A::* p_fun) () = & A::g;
    
    x = a.*p_int;
    // x = a.*p_fun(); //错误 因为函数调用()的优先级更高 所以p_fun()被解释成一个表达式 这个表达式由于返回的不是一个成员指针 所以类型不会匹配
    x = (a.*p_fun)();//正确 加上括号就对了
    // p_int++;//错误
    // p_fun += 1;//错误
    return 0;
}

