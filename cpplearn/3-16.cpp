// 对象初始化
// 在对象的构造的时候，需要初始化数据成员 
// 如果我们不特意说明 c++都会缺省地自己去调用该数据成员的无参构造函数进行构造和初始化
// 对于只读和引用类型的非静态数据成员，如果不初始化，编译器会warning
// 如果在定义的同时初始化同样会warning告诉你这是c++11才有的 如果编译的时候加上 -std=c++11则不会警告
// 因此最好的方法还是自己写一个构造函数去初始化他

//example -1
// class A{
//     const int a=1;
//     const int & b =a;
//     const int c;//这个时候只会warning 因为c的构造使用的是默认的构造函数 会对c负责（初始化）
//     }
// };
// //example 0
// class A{
//     const int a=1;
//     const int & b =a;
//     const int c;
//     A(){
// //error : A必须显式初始化const 成员c
//     }
// };
// //example 1
// class A{
//     const int a=1;
//     const int & b =a;
//     const int c;
//     A(){
//         //c=1;//error 这个时候c已经被构造出来了 再赋值已经不被允许
//         //那么也就是说c已经被构造出来了对吧
//     }
// };
//example 2
// class B{
//     const int a=1;
//     const int & b =a;
//     const int c;
//     B():c(1){
//         //这个时候编译终于通过了 也就是说如果我们自己写了无参构造函数 则c++就不会帮我们调用默认的构造函数了?
//         // 那么为什么a和b又没问题呢？ 因为他们已经被初始化了吗？那他们又是谁构造出来的呢？
//         //如何调用了默认构造函数 那么为什么c不会被构造呢 如果没有调用 那么a和b的初始化又是怎么做到的呢？
//     }
// };
// answer!
// 默认构造函数 default constrctor  (没有任何实参)
// 如果我们的类没有显式地定义构造函数 
// 那么编译器会帮我们隐式定义一个合成的默认构造函数 synthesized default constructor
// 其初始化规则如下：1.如果存在类内初始值则使用初始值来初始化成员 2.否则使用默认初始化

// 关于默认构造函数的一些注释
// 只有在我们没有定义任何构造函数的时候才会帮我们定义默认构造函数 因此一旦我们定义了一个其他的构造函数则编译器不再帮我们构造默认构造函数
// 此时类将没有默认构造函数
// 可以使用 classname() = defualt ; 显式使用默认构造函数
// 如果一个类A中有一个类B的成员 类B没有默认构造函数 那么编译器将无法初始化这个成员

// 因此大多数情况下我们需要自己写一个构造函数 而且既然我们写了构造函数 那么最好给他写一个默认构造函数
// 然而这种时候还是会有一些问题待讨论
// 构造函数的参数列表之后有一个初始化的阶段
// 在这个阶段可以显式地初始化成员 
// 但是如果没有写出一个成员 那么这个成员仍旧会使用默认构造函数来初始化自己（默认构造函数会先检查是否有类内初始值）
// 然而存在一些情况 他的初始值是不可以缺少的 那就是1.const 2. & 3.一个属于某种类类型而那个类又没有定义默认构造函数的成员
// 在这些情况下编译器调用默认初始化将会出错 example 0
// 我们可以通过在类内定义初始值或者使用初始值列表的方式来指定初始化
// 建议：使用构造函数初始值列表来初始化这些成员

// 那么类内初始化和初始值列表初始化之间是什么关系呢？ 
// 下面代码说明类初始值列表初始化与类内初始化冲突时 类初始化列表优先
// 输出 2
//example 3
#include <iostream>
class B{
    public:
    int a=1;
    B():a(2){
    }
};
int main(int argc, char const *argv[])
{   
    B x;
    std::cout<<x.a;
    return 0;
}
// 其实这里还要说明一个初始化可以使用多个参数
class A{
    int a;
A (int x){a=x;std::cout<<a;}
}
A tmp(1,2);// == A tmp(2);
// 初始化时会从左到右顺序运算 从而1,2 等价于 2


// 初始化的顺序
// 成员初始化的顺序与他在类中的定义一致
// 最好是使用构造函数的参数来初始化成员 而不是使用其他成员初始化成员
// 说到构造函数的参数 需要提出一点： 如果一个构造函数为所有参数提供了默认参数 则等于定义了默认构造函数
class B{
    public:
    int a=1;
    B(int b=1):a(b){
    }
};
// 以上函数的构造函数成为了一个默认构造函数 且利用这种方法可以很好的给成员初始化

// 最后 使用默认构造函数对对象进行初始化的方法是

class_type object; //定义了一个对象 并且使用默认构造函数初始化
// 而不是
class_type objdect();//定义了一个函数 你懂的

//如果一个类只有公有成员 且没有定义构造函数则可以使用花括号的形式初始化
//这是因为只有公有成员所有可以都直接访问 然后没有构造函数因此可以自己使用花括号初始化
//如果有私有成员则不能访问 有构造函数则必须使用构造函数 这一点可以联想到strcut union等类型 其实默认就是这样子使用的
unino C{
    char c;
    int i,j;
    ~C();
}c={58}; //union只需要初始化他的第一个成员就可以了 其他成员由于共享空间从而自动初始化
// 总而言之 这种情况下可以在花括号里面使用逗号隔开初始化成员 提供的值不多于对象内的成员数量就可以了
struct B{
    int i,j;
}b={1,2};//right
//b={1,2,3};//wrong


//最后的最后 如果用new一次构造一个元素 则可以使用任意构造函数 如果用new一次构造一个数组 那么只能使用无参构造